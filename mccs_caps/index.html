<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `mccs_caps` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, mccs_caps">

    <title>mccs_caps - Rust</title>

    <link rel="stylesheet" type="text/css" href="../normalize.css">
    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    
    
</head>
<body class="rustdoc mod">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        <div class="sidebar-menu">&#9776;</div>
        
        <p class='location'>Crate mccs_caps</p><div class="sidebar-elems"><div class="block items"><ul><li><a href="#macros">Macros</a></li><li><a href="#functions">Functions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'mccs_caps', ty: 'mod', relpath: '../'};</script></div>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content">
<h1 class='fqn'><span class='in-band'>Crate <a class="mod" href=''>mccs_caps</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a class='srclink' href='../src/mccs_caps/lib.rs.html#1-406' title='goto source code'>[src]</a></span></h1>
<div class='docblock'><p>MCCS compliant displays will report their supported capabilities in a string
retrieved over DDC/CI. The format of this string is specified in the DDC
specification, MCCS, and ACCESS.bus section 7. This crate parses the
capability string into structured data.</p>
</div><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.add_return_error.html"
                                  title='macro mccs_caps::add_return_error'>add_return_error</a></td>
                           <td class='docblock-short'>
                                <p>Add an error if the child parser fails</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.alt.html"
                                  title='macro mccs_caps::alt'>alt</a></td>
                           <td class='docblock-short'>
                                <p>Try a list of parsers and return the result of the first successful one</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.alt_complete.html"
                                  title='macro mccs_caps::alt_complete'>alt_complete</a></td>
                           <td class='docblock-short'>
                                <p>Is equivalent to the <code>alt!</code> combinator, except that it will not return <code>Incomplete</code>
when one of the constituting parsers returns <code>Incomplete</code>. Instead, it will try the
next alternative in the chain.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.apply.html"
                                  title='macro mccs_caps::apply'>apply</a></td>
                           <td class='docblock-short'>
                                <p>emulate function currying: <code>apply!(my_function, arg1, arg2, ...)</code> becomes <code>my_function(input, arg1, arg2, ...)</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.apply_m.html"
                                  title='macro mccs_caps::apply_m'>apply_m</a></td>
                           <td class='docblock-short'>
                                <p>emulate function currying for method calls on structs
<code>apply_m!(self.my_function, arg1, arg2, ...)</code> becomes <code>self.my_function(input, arg1, arg2, ...)</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.bits.html"
                                  title='macro mccs_caps::bits'>bits</a></td>
                           <td class='docblock-short'>
                                <p><code>bits!( parser ) =&gt; ( &amp;[u8], (&amp;[u8], usize) -&gt; IResult&lt;(&amp;[u8], usize), T&gt; ) -&gt; IResult&lt;&amp;[u8], T&gt;</code>
transforms its byte slice input into a bit stream for the underlying parsers</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.bytes.html"
                                  title='macro mccs_caps::bytes'>bytes</a></td>
                           <td class='docblock-short'>
                                <p>Counterpart to bits,
<code>bytes!( parser ) =&gt; ( (&amp;[u8], usize), &amp;[u8] -&gt; IResult&lt;&amp;[u8], T&gt; ) -&gt; IResult&lt;(&amp;[u8], usize), T&gt;</code>,
transforms its bits stream input into a byte slice for the underlying parsers. If we start in the
middle of a byte throws away the bits until the end of the byte.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.call.html"
                                  title='macro mccs_caps::call'>call</a></td>
                           <td class='docblock-short'>
                                <p>Used to wrap common expressions and function as macros</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.call_m.html"
                                  title='macro mccs_caps::call_m'>call_m</a></td>
                           <td class='docblock-short'>
                                <p>Used to called methods then move self back into self</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.char.html"
                                  title='macro mccs_caps::char'>char</a></td>
                           <td class='docblock-short'>
                                <p>matches one character: `char!(char) =&gt; &amp;[u8] -&gt; IResult&lt;&amp;[u8], char&gt;</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.closure.html"
                                  title='macro mccs_caps::closure'>closure</a></td>
                           <td class='docblock-short'>
                                <p>Wraps a parser in a closure</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.compiler_error.html"
                                  title='macro mccs_caps::compiler_error'>compiler_error</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.complete.html"
                                  title='macro mccs_caps::complete'>complete</a></td>
                           <td class='docblock-short'>
                                <p>replaces a <code>Incomplete</code> returned by the child parser
with an <code>Error</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.cond.html"
                                  title='macro mccs_caps::cond'>cond</a></td>
                           <td class='docblock-short'>
                                <p><code>cond!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;</code>
Conditional combinator</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.cond_reduce.html"
                                  title='macro mccs_caps::cond_reduce'>cond_reduce</a></td>
                           <td class='docblock-short'>
                                <p><code>cond_reduce!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
Conditional combinator with error</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.cond_with_error.html"
                                  title='macro mccs_caps::cond_with_error'>cond_with_error</a></td>
                           <td class='docblock-short'>
                                <p><code>cond_with_error!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;</code>
Conditional combinator</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.consumer_from_parser.html"
                                  title='macro mccs_caps::consumer_from_parser'>consumer_from_parser</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.count.html"
                                  title='macro mccs_caps::count'>count</a></td>
                           <td class='docblock-short'>
                                <p><code>count!(I -&gt; IResult&lt;I,O&gt;, nb) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the child parser a specified number of times</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.count_fixed.html"
                                  title='macro mccs_caps::count_fixed'>count_fixed</a></td>
                           <td class='docblock-short'>
                                <p><code>count_fixed!(O, I -&gt; IResult&lt;I,O&gt;, nb) =&gt; I -&gt; IResult&lt;I, [O; nb]&gt;</code>
Applies the child parser a fixed number of times and returns a fixed size array
The type must be specified and it must be <code>Copy</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.dbg.html"
                                  title='macro mccs_caps::dbg'>dbg</a></td>
                           <td class='docblock-short'>
                                <p>Prints a message if the parser fails</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.dbg_dmp.html"
                                  title='macro mccs_caps::dbg_dmp'>dbg_dmp</a></td>
                           <td class='docblock-short'>
                                <p>Prints a message and the input if the parser fails</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.delimited.html"
                                  title='macro mccs_caps::delimited'>delimited</a></td>
                           <td class='docblock-short'>
                                <p><code>delimited!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,U&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
delimited(opening, X, closing) returns X</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.do_parse.html"
                                  title='macro mccs_caps::do_parse'>do_parse</a></td>
                           <td class='docblock-short'>
                                <p><code>do_parse!(I-&gt;IResult&lt;I,A&gt; &gt;&gt; I-&gt;IResult&lt;I,B&gt; &gt;&gt; ... I-&gt;IResult&lt;I,X&gt; , ( O ) ) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
do_parse applies sub parsers in a sequence.
it can store intermediary results and make them available
for later parsers</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.eat_separator.html"
                                  title='macro mccs_caps::eat_separator'>eat_separator</a></td>
                           <td class='docblock-short'>
                                <p>helper macros to build a separator parser</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.eof.html"
                                  title='macro mccs_caps::eof'>eof</a></td>
                           <td class='docblock-short'>
                                <p><code>eof!()</code> returns its input if it is at the end of input data</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.error_code.html"
                                  title='macro mccs_caps::error_code'>error_code</a></td>
                           <td class='docblock-short'>
                                <p>creates a parse error from a <code>nom::ErrorKind</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.error_node.html"
                                  title='macro mccs_caps::error_node'>error_node</a></td>
                           <td class='docblock-short'>
                                <p>creates a parse error from a <code>nom::ErrorKind</code>
and the next error in the parsing tree.
if &quot;verbose-errors&quot; is not activated,
it default to only the error code</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.error_node_position.html"
                                  title='macro mccs_caps::error_node_position'>error_node_position</a></td>
                           <td class='docblock-short'>
                                <p>creates a parse error from a <code>nom::ErrorKind</code>,
the position in the input and the next error in
the parsing tree.
if &quot;verbose-errors&quot; is not activated,
it default to only the error code</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.error_position.html"
                                  title='macro mccs_caps::error_position'>error_position</a></td>
                           <td class='docblock-short'>
                                <p>creates a parse error from a <code>nom::ErrorKind</code>
and the position in the input
if &quot;verbose-errors&quot; is not activated,
it default to only the error code</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.escaped.html"
                                  title='macro mccs_caps::escaped'>escaped</a></td>
                           <td class='docblock-short'>
                                <p><code>escaped!(&amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;, T, &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
matches a byte string with escaped characters.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.escaped_transform.html"
                                  title='macro mccs_caps::escaped_transform'>escaped_transform</a></td>
                           <td class='docblock-short'>
                                <p><code>escaped_transform!(&amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;, T, &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], Vec&lt;T&gt;&gt;</code>
matches a byte string with escaped characters.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.expr_opt.html"
                                  title='macro mccs_caps::expr_opt'>expr_opt</a></td>
                           <td class='docblock-short'>
                                <p><code>expr_opt!(Option&lt;O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
evaluate an expression that returns a Option<T> and returns a IResult::Done(I,T) if Some</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.expr_res.html"
                                  title='macro mccs_caps::expr_res'>expr_res</a></td>
                           <td class='docblock-short'>
                                <p><code>expr_res!(Result&lt;E,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
evaluate an expression that returns a Result<T,E> and returns a IResult::Done(I,T) if Ok</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.fix_error.html"
                                  title='macro mccs_caps::fix_error'>fix_error</a></td>
                           <td class='docblock-short'>
                                <p>translate parser result from IResult<I,O,u32> to IResult<I,O,E> with a custom type</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.flat_map.html"
                                  title='macro mccs_caps::flat_map'>flat_map</a></td>
                           <td class='docblock-short'>
                                <p><code>flat_map!(R -&gt; IResult&lt;R,S&gt;, S -&gt; IResult&lt;S,T&gt;) =&gt; R -&gt; IResult&lt;R, T&gt;</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.fold_many0.html"
                                  title='macro mccs_caps::fold_many0'>fold_many0</a></td>
                           <td class='docblock-short'>
                                <p><code>fold_many0!(I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;</code>
Applies the parser 0 or more times and folds the list of return values</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.fold_many1.html"
                                  title='macro mccs_caps::fold_many1'>fold_many1</a></td>
                           <td class='docblock-short'>
                                <p><code>fold_many1!(I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;</code>
Applies the parser 1 or more times and folds the list of return values</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.fold_many_m_n.html"
                                  title='macro mccs_caps::fold_many_m_n'>fold_many_m_n</a></td>
                           <td class='docblock-short'>
                                <p><code>fold_many_m_n!(usize, usize, I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;</code>
Applies the parser between m and n times (n included) and folds the list of return value</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.i16.html"
                                  title='macro mccs_caps::i16'>i16</a></td>
                           <td class='docblock-short'>
                                <p>if the parameter is nom::Endianness::Big, parse a big endian i16 integer,
otherwise a little endian i16 integer</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.i32.html"
                                  title='macro mccs_caps::i32'>i32</a></td>
                           <td class='docblock-short'>
                                <p>if the parameter is nom::Endianness::Big, parse a big endian i32 integer,
otherwise a little endian i32 integer</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.i64.html"
                                  title='macro mccs_caps::i64'>i64</a></td>
                           <td class='docblock-short'>
                                <p>if the parameter is nom::Endianness::Big, parse a big endian i64 integer,
otherwise a little endian i64 integer</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.is_a.html"
                                  title='macro mccs_caps::is_a'>is_a</a></td>
                           <td class='docblock-short'>
                                <p><code>is_a!(&amp;[T]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes that appear in the provided array</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.is_a_s.html"
                                  title='macro mccs_caps::is_a_s'>is_a_s</a></td>
                           <td class='docblock-short'>
                                <p><code>is_a_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters that appear in the provided array</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.is_not.html"
                                  title='macro mccs_caps::is_not'>is_not</a></td>
                           <td class='docblock-short'>
                                <p><code>is_not!(&amp;[T:AsBytes]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes that do not appear in the provided array</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.is_not_s.html"
                                  title='macro mccs_caps::is_not_s'>is_not_s</a></td>
                           <td class='docblock-short'>
                                <p><code>is_not_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters that do not appear in the provided array</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.length_bytes.html"
                                  title='macro mccs_caps::length_bytes'>length_bytes</a></td>
                           <td class='docblock-short'>
                                <p><code>length_bytes!(&amp;[T] -&gt; IResult&lt;&amp;[T], nb&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
Gets a number from the first parser, then extracts that many bytes from the
remaining stream</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.length_count.html"
                                  title='macro mccs_caps::length_count'>length_count</a></td>
                           <td class='docblock-short'>
                                <p><code>length_count!(I -&gt; IResult&lt;I, nb&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
gets a number from the first parser, then applies the second parser that many times</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.length_data.html"
                                  title='macro mccs_caps::length_data'>length_data</a></td>
                           <td class='docblock-short'>
                                <p><code>length_data!(I -&gt; IResult&lt;I, nb&gt;) =&gt; O</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.length_value.html"
                                  title='macro mccs_caps::length_value'>length_value</a></td>
                           <td class='docblock-short'>
                                <p><code>length_value!(I -&gt; IResult&lt;I, nb&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
gets a number from the first parser, takes a subslice of the input of that size,
then applies the second parser on that subslice. If the second parser returns
<code>Incomplete</code>, <code>length_value</code> will return an error</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.many0.html"
                                  title='macro mccs_caps::many0'>many0</a></td>
                           <td class='docblock-short'>
                                <p><code>many0!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the parser 0 or more times and returns the list of results in a Vec</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.many1.html"
                                  title='macro mccs_caps::many1'>many1</a></td>
                           <td class='docblock-short'>
                                <p><code>many1!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the parser 1 or more times and returns the list of results in a Vec</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.many_m_n.html"
                                  title='macro mccs_caps::many_m_n'>many_m_n</a></td>
                           <td class='docblock-short'>
                                <p><code>many_m_n!(usize, usize, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the parser between m and n times (n included) and returns the list of
results in a Vec</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.many_till.html"
                                  title='macro mccs_caps::many_till'>many_till</a></td>
                           <td class='docblock-short'>
                                <p><code>many_till!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (Vec&lt;O&gt;, P)&gt;</code>
Applies the first parser until the second applies. Returns a tuple containing the list
of results from the first in a Vec and the result of the second.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.map.html"
                                  title='macro mccs_caps::map'>map</a></td>
                           <td class='docblock-short'>
                                <p><code>map!(I -&gt; IResult&lt;I,O&gt;, O -&gt; P) =&gt; I -&gt; IResult&lt;I, P&gt;</code>
maps a function on the result of a parser</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.map_opt.html"
                                  title='macro mccs_caps::map_opt'>map_opt</a></td>
                           <td class='docblock-short'>
                                <p><code>map_opt!(I -&gt; IResult&lt;I,O&gt;, O -&gt; Option&lt;P&gt;) =&gt; I -&gt; IResult&lt;I, P&gt;</code>
maps a function returning an Option on the output of a parser</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.map_res.html"
                                  title='macro mccs_caps::map_res'>map_res</a></td>
                           <td class='docblock-short'>
                                <p><code>map_res!(I -&gt; IResult&lt;I,O&gt;, O -&gt; Result&lt;P&gt;) =&gt; I -&gt; IResult&lt;I, P&gt;</code>
maps a function returning a Result on the output of a parser</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.method.html"
                                  title='macro mccs_caps::method'>method</a></td>
                           <td class='docblock-short'>
                                <p>Makes a method from a parser combination</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.named.html"
                                  title='macro mccs_caps::named'>named</a></td>
                           <td class='docblock-short'>
                                <p>Makes a function from a parser combination</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.named_args.html"
                                  title='macro mccs_caps::named_args'>named_args</a></td>
                           <td class='docblock-short'>
                                <p>Makes a function from a parser combination with arguments.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.named_attr.html"
                                  title='macro mccs_caps::named_attr'>named_attr</a></td>
                           <td class='docblock-short'>
                                <p>Makes a function from a parser combination, with attributes</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.none_of.html"
                                  title='macro mccs_caps::none_of'>none_of</a></td>
                           <td class='docblock-short'>
                                <p>matches anything but the provided characters</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.not.html"
                                  title='macro mccs_caps::not'>not</a></td>
                           <td class='docblock-short'>
                                <p><code>not!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
returns a result only if the embedded parser returns Error or Incomplete
does not consume the input</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.one_of.html"
                                  title='macro mccs_caps::one_of'>one_of</a></td>
                           <td class='docblock-short'>
                                <p>matches one of the provided characters</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.opt.html"
                                  title='macro mccs_caps::opt'>opt</a></td>
                           <td class='docblock-short'>
                                <p><code>opt!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;</code>
make the underlying parser optional</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.opt_res.html"
                                  title='macro mccs_caps::opt_res'>opt_res</a></td>
                           <td class='docblock-short'>
                                <p><code>opt_res!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Result&lt;nom::Err,O&gt;&gt;</code>
make the underlying parser optional</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.pair.html"
                                  title='macro mccs_caps::pair'>pair</a></td>
                           <td class='docblock-short'>
                                <p><code>pair!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (O,P)&gt;</code>
pair(X,Y), returns (x,y)</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.parse_to.html"
                                  title='macro mccs_caps::parse_to'>parse_to</a></td>
                           <td class='docblock-short'>
                                <p><code>parse_to!(O) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
uses the <code>parse</code> method from <code>std::str::FromStr</code> to convert the current
input to the specified type</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.peek.html"
                                  title='macro mccs_caps::peek'>peek</a></td>
                           <td class='docblock-short'>
                                <p><code>peek!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
returns a result without consuming the input</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.permutation.html"
                                  title='macro mccs_caps::permutation'>permutation</a></td>
                           <td class='docblock-short'>
                                <p><code>permutation!(I -&gt; IResult&lt;I,A&gt;, I -&gt; IResult&lt;I,B&gt;, ... I -&gt; IResult&lt;I,X&gt; ) =&gt; I -&gt; IResult&lt;I, (A,B,...X)&gt;</code>
applies its sub parsers in a sequence, but independent from their order
this parser will only succeed if all of its sub parsers succeed</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.preceded.html"
                                  title='macro mccs_caps::preceded'>preceded</a></td>
                           <td class='docblock-short'>
                                <p><code>preceded!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
preceded(opening, X) returns X</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.recognize.html"
                                  title='macro mccs_caps::recognize'>recognize</a></td>
                           <td class='docblock-short'>
                                <p><code>recognize!(I -&gt; IResult&lt;I, O&gt; ) =&gt; I -&gt; IResult&lt;I, I&gt;</code>
if the child parser was successful, return the consumed input as produced value</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.return_error.html"
                                  title='macro mccs_caps::return_error'>return_error</a></td>
                           <td class='docblock-short'>
                                <p>Prevents backtracking if the child parser fails</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.sep.html"
                                  title='macro mccs_caps::sep'>sep</a></td>
                           <td class='docblock-short'>
                                <p>sep is the parser rewriting macro for whitespace separated formats</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.separated_list.html"
                                  title='macro mccs_caps::separated_list'>separated_list</a></td>
                           <td class='docblock-short'>
                                <p><code>separated_list!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
separated_list(sep, X) returns Vec<X> will return Incomplete if there may be more elements</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.separated_list_complete.html"
                                  title='macro mccs_caps::separated_list_complete'>separated_list_complete</a></td>
                           <td class='docblock-short'>
                                <p><code>separated_list_complete!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
This is equivalent to the <code>separated_list!</code> combinator, except that it will return <code>Error</code>
when either the separator or element subparser returns <code>Incomplete</code>.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.separated_nonempty_list.html"
                                  title='macro mccs_caps::separated_nonempty_list'>separated_nonempty_list</a></td>
                           <td class='docblock-short'>
                                <p><code>separated_nonempty_list!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
separated_nonempty_list(sep, X) returns Vec<X> will return Incomplete if there may be more elements</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.separated_nonempty_list_complete.html"
                                  title='macro mccs_caps::separated_nonempty_list_complete'>separated_nonempty_list_complete</a></td>
                           <td class='docblock-short'>
                                <p><code>separated_nonempty_list_complete!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
This is equivalent to the <code>separated_nonempty_list!</code> combinator, except that it will return
<code>Error</code> when either the separator or element subparser returns <code>Incomplete</code>.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.separated_pair.html"
                                  title='macro mccs_caps::separated_pair'>separated_pair</a></td>
                           <td class='docblock-short'>
                                <p><code>separated_pair!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I, T&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (O,P)&gt;</code>
separated_pair(X,sep,Y) returns (x,y)</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.switch.html"
                                  title='macro mccs_caps::switch'>switch</a></td>
                           <td class='docblock-short'>
                                <p><code>switch!(I -&gt; IResult&lt;I,P&gt;, P =&gt; I -&gt; IResult&lt;I,O&gt; | ... | P =&gt; I -&gt; IResult&lt;I,O&gt; ) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
choose the next parser depending on the result of the first one, if successful,
and returns the result of the second parser</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.tag.html"
                                  title='macro mccs_caps::tag'>tag</a></td>
                           <td class='docblock-short'>
                                <p><code>tag!(&amp;[T]: nom::AsBytes) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
declares a byte array as a suite to recognize</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.tag_bits.html"
                                  title='macro mccs_caps::tag_bits'>tag_bits</a></td>
                           <td class='docblock-short'>
                                <p>matches an integer pattern to a bitstream. The number of bits of the input to compare must be specified</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.tag_no_case.html"
                                  title='macro mccs_caps::tag_no_case'>tag_no_case</a></td>
                           <td class='docblock-short'>
                                <p><code>tag_no_case!(&amp;[T]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
declares a case insensitive ascii string as a suite to recognize</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.tag_no_case_s.html"
                                  title='macro mccs_caps::tag_no_case_s'>tag_no_case_s</a></td>
                           <td class='docblock-short'>
                                <p><code>tag_no_case_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
declares a case-insensitive string as a suite to recognize</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.tag_s.html"
                                  title='macro mccs_caps::tag_s'>tag_s</a></td>
                           <td class='docblock-short'>
                                <p><code>tag_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
declares a string as a suite to recognize</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take.html"
                                  title='macro mccs_caps::take'>take</a></td>
                           <td class='docblock-short'>
                                <p><code>take!(nb) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
generates a parser consuming the specified number of bytes</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_bits.html"
                                  title='macro mccs_caps::take_bits'>take_bits</a></td>
                           <td class='docblock-short'>
                                <p><code>take_bits!(type, nb) =&gt; ( (&amp;[T], usize), U, usize) -&gt; IResult&lt;(&amp;[T], usize), U&gt;</code>
generates a parser consuming the specified number of bits.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_s.html"
                                  title='macro mccs_caps::take_s'>take_s</a></td>
                           <td class='docblock-short'>
                                <p><code>take_s!(nb) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
generates a parser consuming the specified number of characters</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_str.html"
                                  title='macro mccs_caps::take_str'>take_str</a></td>
                           <td class='docblock-short'>
                                <p><code>take_str!(nb) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;str&gt;</code>
same as take! but returning a &amp;str</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_till.html"
                                  title='macro mccs_caps::take_till'>take_till</a></td>
                           <td class='docblock-short'>
                                <p><code>take_till!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes until the provided function succeeds</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_till1.html"
                                  title='macro mccs_caps::take_till1'>take_till1</a></td>
                           <td class='docblock-short'>
                                <p><code>take_till1!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest non empty list of bytes until the provided function succeeds</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_till1_s.html"
                                  title='macro mccs_caps::take_till1_s'>take_till1_s</a></td>
                           <td class='docblock-short'>
                                <p><code>take_till1_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest non empty list of characters until the provided function succeeds</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_till_s.html"
                                  title='macro mccs_caps::take_till_s'>take_till_s</a></td>
                           <td class='docblock-short'>
                                <p><code>take_till_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters until the provided function succeeds</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until.html"
                                  title='macro mccs_caps::take_until'>take_until</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data until it finds the specified tag</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until1.html"
                                  title='macro mccs_caps::take_until1'>take_until1</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until1!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data until it finds the specified tag</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until_and_consume.html"
                                  title='macro mccs_caps::take_until_and_consume'>take_until_and_consume</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_and_consume!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
generates a parser consuming bytes until the specified byte sequence is found, and consumes it</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until_and_consume1.html"
                                  title='macro mccs_caps::take_until_and_consume1'>take_until_and_consume1</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_and_consume1!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
generates a parser consuming bytes (at least 1) until the specified byte sequence is found, and consumes it</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until_and_consume_s.html"
                                  title='macro mccs_caps::take_until_and_consume_s'>take_until_and_consume_s</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_and_consume_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
generates a parser consuming all chars until the specified string is found and consumes it</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until_either.html"
                                  title='macro mccs_caps::take_until_either'>take_until_either</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_either!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until_either_and_consume.html"
                                  title='macro mccs_caps::take_until_either_and_consume'>take_until_either_and_consume</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_either_and_consume!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data until it finds any of the specified characters, and consume it</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until_s.html"
                                  title='macro mccs_caps::take_until_s'>take_until_s</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
generates a parser consuming all chars until the specified string is found and leaves it in the remaining input</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_while.html"
                                  title='macro mccs_caps::take_while'>take_while</a></td>
                           <td class='docblock-short'>
                                <p><code>take_while!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes until the provided function fails.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_while1.html"
                                  title='macro mccs_caps::take_while1'>take_while1</a></td>
                           <td class='docblock-short'>
                                <p><code>take_while1!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest (non empty) list of bytes until the provided function fails.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_while1_s.html"
                                  title='macro mccs_caps::take_while1_s'>take_while1_s</a></td>
                           <td class='docblock-short'>
                                <p><code>take_while1_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest (non empty) list of characters until the provided function fails.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_while_s.html"
                                  title='macro mccs_caps::take_while_s'>take_while_s</a></td>
                           <td class='docblock-short'>
                                <p><code>take_while_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters until the provided function fails.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.tap.html"
                                  title='macro mccs_caps::tap'>tap</a></td>
                           <td class='docblock-short'>
                                <p><code>tap!(name: I -&gt; IResult&lt;I,O&gt; =&gt; { block }) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
allows access to the parser&#39;s result without affecting it</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.terminated.html"
                                  title='macro mccs_caps::terminated'>terminated</a></td>
                           <td class='docblock-short'>
                                <p><code>terminated!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,T&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
terminated(X, closing) returns X</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.try_parse.html"
                                  title='macro mccs_caps::try_parse'>try_parse</a></td>
                           <td class='docblock-short'>
                                <p>A bit like <code>std::try!</code>, this macro will return the remaining input and parsed value if the child parser returned <code>Done</code>,
and will do an early return for <code>Error</code> and <code>Incomplete</code>
this can provide more flexibility than <code>do_parse!</code> if needed</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.tuple.html"
                                  title='macro mccs_caps::tuple'>tuple</a></td>
                           <td class='docblock-short'>
                                <p><code>tuple!(I-&gt;IResult&lt;I,A&gt;, I-&gt;IResult&lt;I,B&gt;, ... I-&gt;IResult&lt;I,X&gt;) =&gt; I -&gt; IResult&lt;I, (A, B, ..., X)&gt;</code>
chains parsers and assemble the sub results in a tuple.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.u16.html"
                                  title='macro mccs_caps::u16'>u16</a></td>
                           <td class='docblock-short'>
                                <p>if the parameter is nom::Endianness::Big, parse a big endian u16 integer,
otherwise a little endian u16 integer</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.u32.html"
                                  title='macro mccs_caps::u32'>u32</a></td>
                           <td class='docblock-short'>
                                <p>if the parameter is nom::Endianness::Big, parse a big endian u32 integer,
otherwise a little endian u32 integer</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.u64.html"
                                  title='macro mccs_caps::u64'>u64</a></td>
                           <td class='docblock-short'>
                                <p>if the parameter is nom::Endianness::Big, parse a big endian u64 integer,
otherwise a little endian u64 integer</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.value.html"
                                  title='macro mccs_caps::value'>value</a></td>
                           <td class='docblock-short'>
                                <p><code>value!(T, R -&gt; IResult&lt;R, S&gt; ) =&gt; R -&gt; IResult&lt;R, T&gt;</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.verify.html"
                                  title='macro mccs_caps::verify'>verify</a></td>
                           <td class='docblock-short'>
                                <p><code>verify!(I -&gt; IResult&lt;I,O&gt;, O -&gt; bool) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
returns the result of the child parser if it satisfies a verification function</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.wrap_sep.html"
                                  title='macro mccs_caps::wrap_sep'>wrap_sep</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.ws.html"
                                  title='macro mccs_caps::ws'>ws</a></td>
                           <td class='docblock-short'>
                                <p><code>ws!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code></p>
                           </td>
                       </tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.parse_capabilities.html"
                                  title='fn mccs_caps::parse_capabilities'>parse_capabilities</a></td>
                           <td class='docblock-short'>
                                <p>Parses a MCCS capability string.</p>
                           </td>
                       </tr></table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>↑</dt>
                    <dd>Move up in search results</dd>
                    <dt>↓</dt>
                    <dd>Move down in search results</dd>
                    <dt>↹</dt>
                    <dd>Switch tab</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt style="width:31px;">+ / -</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "mccs_caps";
    </script>
    <script src="../main.js"></script>
    <script defer src="../search-index.js"></script>
</body>
</html>